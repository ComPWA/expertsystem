# [ADR-002] Inserting dynamics

- **Status**: proposed
- **Deciders**: @redeboer @spflueger

## Context and problem statement

Dynamics are formulated in terms of:

- an **expression**
- a set of **parameters** in that expression that can be tweaked (optimized)
- a set of (kinematic) **variables** to which the expression applies

They are meant to parametrize a decaying particle.

### Technical story

- [#124](https://github.com/ComPWA/expertsystem/issues/124): see
  {ref}`adr/002:Issues with existing set-up`.
- [#440](https://github.com/ComPWA/expertsystem/issues/440): no way to supply
  custom dynamics. Or at least, {mod}`tensorwaves` does not understand those
  custom dynamics.
- [ADR-001](./001.md): parameters _and_ variables are to be expressed as
  `sympy.Symbol`s.
- [#454](https://github.com/ComPWA/expertsystem/pull/454): dynamics are
  specified as a mapping of `sympy.Function` to a `sympy.Expr`, but now there
  is no way to supply those `sympy.Expr`s with expected `sympy.Symbol`s
  (parameters and variables).

### Issues with existing set-up

- There is no clear way to apply dynamics functions to a specific decaying
  particle, that is, to a specific edge of the `StateTransitionGraph`s (`STG`).
  Currently, we just work with a mapping of `Particle`s to some dynamics
  expression, but this is not feasible when there there are identical particles
  on the edges.
- The set of variables to which a dynamics expression applies, is determined by
  the position within the `STG` that it is applied to. For instance, a
  relativistic Breit-Wigner that is applied to the resonance in some 1-to-3
  isobar decay (described by an `STG` with final state edges 2, 3, 4 and
  intermediate edge 1) would work on the invariant mass of edge 3 and 4
  (`mSq_3+4`).
- Just like variables, parameters need to be identifiable from their position
  within the `STG` (take a relativistic Breit-Wigner _with form factors_, which
  would require break-up momentum as a parameter), but also require some
  suggested starting value (e.g. expected pole position). These starting values
  are usually taken from the edge and node properties within the `STG`.

## Decision drivers

### Solution requirements

1. It is easy to apply dynamics to specific components of the `STG`s. Note:
   it's important that the dynamics can be applied to resonances of some
   **selected** graphs and not generally all graphs in which the resonance
   appears.
2. The parameters that a dynamics functions requires, are registered
   automatically and linked together.
3. Where possible, suggested (initial) parameter values are provided as well.
4. Kinematic variables used in dynamics functions are also linked
   appropriately.
5. It is easy to define custom dynamics (no boilerplate code).
6. It is possible to use and inspect the dynamics expression itself
   independently from the `expertsystem`.

## Considered solutions

To satisfy [**requirement 1**](#solution-requirements), we propose the
following syntax:

```python
# model: ModelInfo
# graph: StateTransitionGraph
model.set_dynamics(graph, edge_id=1, expression_builder)
```

:::{toggle}

Another style would be to have `ModelInfo` contain a reference to the list of
`StateTransitionGraph`s. The user then needs some other way to express which
edges to apply the dynamics function to:

```python
model.set_dynamics(
    filter=lambda p: p.name.startswith("f(0)"),
    edge_id=1,
    expression_builder,
)
```

:::

Here, `expression_builder` is some function or method that can create a
dynamics expression. It can also be a class that contains both the
implementation of the expression and a static method to build itself from a
`StateTransitionGraph`.

The dynamics expression needs to be formulated in such a way that it satisfies
[**requirements 2-5**](#solution-requirements). The following options
illustrate three different ways of formulating a dynamics expression, each
taking a relativistic Breit-Wigner and a relativistic Breit-Wigner _with form
factor_ as example.

```{toctree}
---
maxdepth: 1
---
002/composition
002/function
002/expr
```

## Evaluation

### Pros and Cons

All of the solutions have the following drawbacks:

- There is an implicit assumption on the signature of the expression: the first
  arguments are assumed to be the (kinematic) `variables` and the remaining
  arguments are `parameters`. In addition, the arguments cannot be keywords,
  but have to be positional.
- The number of `variables` and `parameters` is only verified at runtime (no
  static typing, other than a check that each of the elements is
  `sympy.Symbol`).

Composition is the cleanest design, but is less in tune with the design of
{mod}`sympy`. {doc}`002/function` and {doc}`002/expr` follow {mod}`sympy`
implementations, but result in an obscure inheritance hierarchy with implicit
conventions. This can result in some nasty bugs, for instance if one were to
`__call__` method in either the `sympy.Function` or `sympy.Expr`
implementation.

Pros and Cons that are specific to each of the implementations are listed
below.

#### {doc}`002/composition`

- **Positive**
  - Implementation of the expression is transparent
- **Negative** {ref}`adr/002/composition:Alternative signature`.
  - The only way to see that `relativistic_breit_wigner_from_graph` is the
    builder for `relativistic_breit_wigner`, is from its name. This makes it
    implementing custom dynamics inconvenient and error-prone.
  - Signature of the builder can only be checked with a
    {class}`~typing.Protocol`, see {ref}`adr/002/composition:Type checking`.

#### {doc}`002/function`

- **Positive**
  - `DynamicsFunction` behaves as a {class}`~sympy.core.function.Function`
  - Implementation of the builder is kept together with the implementation of
    the expression.
- **Negative**
  - It's not possible to identify variables and parameters

#### {doc}`002/expr`

- **Positive**
  - When
    {doc}`recursing through the amplitude model <sympy:tutorial/manipulation>`,
    it is still possible to identify instances of `DynamicsExpr` (before
    `doit()` has been called).
  - Additional properties and methods can be added and carried around by the
    class.
- **Negative**
  - Boilerplate code required when implementing custom dynamics
  - {ref}`adr/002/expr:Issue with lambdify`

### Requirement evaluation

See [requirements](#solution-requirements).

|                        | 1   | 2   | 3   | 4   | 5   | 6   |
| ---------------------- | --- | --- | --- | --- | --- | --- |
| {doc}`002/composition` | ?   | ?   |     | ?   | ?   | ?   |
| {doc}`002/function`    | ✓   |     |     |     | ✓   | ✓   |
| {doc}`002/expr`        | ✓   | ✓   | ?   | ✓   |     | ✓   |

**?** means it's either inconvenient or error-prone.

## Decision outcome

The `expertsystem` favors **composition over inheritance**: we intend to use
inheritance only to define interfaces, not to insert behavior. As such, the
design of the `expertsystem` is fundamentally different than that of SymPy.
That's another reason to favor composition here: the interfaces are not
determined by the dependency and instead remain
{doc}`contained within the dynamics class <002/composition>`.

We decide to keep responsibilities as separated as possible. This means that:

1. The only responsibility of `set_dynamics` method is to attribute some
   expression (`sympy.Expr`) the correct symbol within the complete amplitude
   model. For now, this position is specified using some `StateTransitionGraph`
   and an edge ID, but this syntax may be improved later (see
   [#458](https://github.com/ComPWA/expertsystem/pull/458)):

   ```python
   def set_dynamics(
           self,
           graph: StateTransitionGraph,
           edge_id: int,
           expression: sy.Expr,
       ) -> None:
           # dynamics_symbol = graph + edge_id
           # self.dynamics[dynamics_symbol] = expression
   ```

2. The user has the responsibility of formulating the `expression` with the
   correct symbols. What we can offer at most is some sort of `VariablePool` to
   facilitate finding the correct symbol names (to avoid typos). For instance:

   ```python
   mass = variable_pool.get_invariant_mass(graph, edge_id)
   ```

   This is not as convenient as the solutions presented above, but the risk
   with something like a `from_graph` builder method, is that it pins down the
   framework to a specific way of building the amplitude model (e.g., one `STG`
   contains enough info to construct a dynamics expression).

3. The `SympyModel` has the responsibility of keeping track of variables and
   parameters, for instance:

   ```python
   @attr.s(kw_only=True)
   class SympyModel:
       top: sy.Expr = attr.ib()
       # intensities: Dict[sy.Symbol, sy.Expr] = attr.ib(default=dict())
       # amplitudes: Dict[sy.Symbol, sy.Expr] = attr.ib(default=dict())
       dynamics: Dict[sy.Symbol, sy.Expr] = attr.ib(default=dict())
       parameters: Set[sy.Symbol]
       variables: Set[sy.Symbol]  # or: VariablePool
   ```

4. A `dynamics` module provides descriptions of common line-shapes as well as
   some helper functions. An example would be:

   ```python
   inv_mass, mass0, gamma0 = build_relativistic_breit_wigner(
       graph, edge_id, particle
   )
   model.set_dynamics(
       graph, edge, relativistic_breit_wigner(inv_mass, mass0, gamma0)
   )
   ```
