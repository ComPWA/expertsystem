# [ADR-003] State transitions

- Status: **proposed**
- Deciders: @redeboer @spflueger

## Context and problem statement

The `reaction` module (in particular the `StateTransitionManager`) generates
allowed transitions between some initial state and a final state and formulates
that in terms of a `list` of `StateTransitionGraph`s.

### Issues with existing set-up

A problem with this structure is that it is **not a safe and user friendly
container**:

1. It's possible to add `StateTransitionGraph`s that do not match in their
   underlying topologies.
2. Info from the decay can only be extracted by using (list) comprehensions on
   the edge and node IDs and their properties.
3. There is no convenient way to probe info about the complete transition (it's
   just a `List[StateTransitionGraph]`).

### Technical story

- [#454](https://github.com/ComPWA/expertsystem/pull/454): there is no
  convenient way to generate names for the `sympy.Symbol`s that are used in the
  eventual `sympy.Expr` that formulates the model. In addition, we need a
  closer link between the transition description (edge IDs etc. of the
  topology) and the mathematical formulation.
- Currently ([`b29081d`](https://github.com/ComPWA/expertsystem/tree/b29081d)),
  resonances are applied to _particles_, not resonances within a transition.
  This is a problem if there are resonance particles that are also in the final
  or initial state or if there are is a 1-to-4 body decay (three intermediate
  edges) with multiple identical resonances.

## Decision drivers

### Solution requirements

Description of the allowed state transition should be complete:

1. Complete and self-contained
2. Immutable
3. Easy to inspect

## Considered solutions

### Follow current set-up

```python
import expertsystem as es

result = es.generate_transitions(
    initial_state=("J/psi(1S)", [-1, +1]),
    final_state=["gamma", "pi0", "pi0"],
    allowed_intermediate_particles=["f(0)(980)", "f(0)(1500)"],
    allowed_interaction_types=["strong", "EM"],
)
type(result)
```

```python
import graphviz

graphs = result.collapse_graphs()
dot = es.io.convert_to_dot(graphs)
graphviz.Source(dot)
```

### Alternative solution

The `Result.solutions` should become a safer container that can be probed, for
instance a `StateTransitions` class:

```python
transitions = result.solutions
```

Some desired properties:

```python
transitions.__class__.__name__ == "StateTransitions"
```

```python
transitions.initial_state == {
    0: (Particle("J/psi(1S)"), [-1, +1]),
}
transitions.final_state == {
    2: (Particle("gamma"), [-1, +1]),
    3: (Particle("pi0"), [0]),
    4: (Particle("pi0"), [0]),
}
transitions.resonances == {
    1: [
        (Particle("f(0)(980)"), [0]),
        (Particle("f(0)(1500)"), [0]),
    ],
}
```

```python
expected_topology = Topology(
    nodes={0, 1},
    edges={
        0: Edge(None, 0),  # J/psi
        1: Edge(0, 1),     # f0
        2: Edge(0, None),  # gamma
        3: Edge(1, None),  # pi0
        4: Edge(1, None),  # pi0
    },
)
transitions.topology == expected_topology
```

```python
len(transitions) == 8
graph = transitions[0]
graph.__class__.__name__ == "StateTransitionGraph[ParticleWithSpin]"

graph.initial_state == {
    0: (Particle("J/psi(1S)"), -1),
}
graph.final_state == {
    2: (Particle("gamma"), -1),
    3: (Particle("pi0"), 0),
    4: (Particle("pi0"), 0),
}
graph.resonances == {
    1: (Particle("f(0)(980)"), 0),
}

transitions.topology == graph.topology
```

## Evaluation

### Pros and Cons

<!--
List some advantages and disadvantages of each of the implementations, possibly
with links (using e.g. {ref} or {doc}) to the proposed solutions.

#### Option 1

- **Positive**:
  1.
  2.
- **Negative**:
  1.
  2.

#### Option 2

- **Positive**:
  1.
  2.
- **Negative**:
  1.
  2.
-->

### Requirement evaluation

See [requirements](#solution-requirements).

<!--
|          | 1   | 2   | 3   | ... |
| -------- | --- | --- | --- | --- |
| Option 1 |     |     |     |     |
| Option 2 |     |     |     |     |
| ...      |     |     |     |     |
-->

## Decision Outcome

1. Remove the `Result` class:
   - raise violated rules as exceptions
   - return only the solutions (currently `List[StateTransitionGraph]`)
2. Wrap the `List[StateTransitionGraph]` solutions in a `StateTransitions`
   class as described above.
